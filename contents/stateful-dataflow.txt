---
title: "Stateful Dataflow"
author: foobar
tags: [programming]
copyright: CC BY-NC
---
Data Flow is represented by a Graph.

Graph = Nodes + Connections.

State in Data Flow

1. Stateless

2. Global

Corruption is easy.

3. Parent / Child

4. Node Local

Node becomes a co-routine.
Destruction of the state is problematic.

5. Concurrent

Graph becomes an OS.
Node becomes a Process.

State Machines
==============

I should be more mathematical, but fuck mathematicians.
If a mathematician ever asks me to add two numbers I will gladly give him <a href="https://code.jquery.com/jquery-1.11.1.min.js">this</a>.

State Machines are like depressed data flows.
Data Flow graph gets giddy and excited on receiving events whereas
State Machines think and brood.

They consult the
    1. Decision table
    2. Past lives
    3. The current input dilemma
    and then commit to an action which begets fruitful data.

The depressed state machine can't do two tasks at a time because it's past will lose meaning.
Every task is like a transaction.

goto's + global variables is like 2.
A C function calling another function is like 3.
A co-routine yielding to another co-routine is 4.
And 5 is Actor Model aka Processes + IPC !

After concurrency, State Machines =~ Data Flow Processes.

Sigh.

It's sad to see functional programmers stuck at 1 when in fact assembly programmers had 5
and Data Driven Style of programming.

In pure assembly, you can do whatever the fuck you want.
RAM is a Decision Table and Co-routines / Processes -- 5 -- are just a Context Switch away !

C / Pascal are a step backwards in programming by going from 5 to 3.

All high level perspectives are flawed.
Forth / Lisp originated in assembly.
By far they still represent the most flexible languages.
I can't even imagine the CPU thrashing done by a real pre-80's Lisp.
Viva Low Level !

