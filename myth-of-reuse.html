<!DOCTYPE html>
<head>
<html>
<meta charset="utf-8">
<title> The Myth of Software Reuse </title>
<link rel="alternate" type="application/rss+xml" title="" href="/feed.xml">
<meta name="viewport" content="width=960,initial-scale=1">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>

  <script src="/vendor/jquery/dist/jquery.min.js"></script>
  <script src="/js/bundle.min.js"></script>
  <link rel="stylesheet" href="/css/styles.less.min.css">

</head>
<body>

<!--[if lt IE 8]>
<p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
<![endif]-->


<nav>
<a href="http://www.foobar.systems"><img src="/images/floppy.png" width="33" height="33"/>Foo Bar Systems</a>
<h1>Harsha / Mr. Foo Bar (‸‶</h1>
<a href="/">Index</a>
<a href="/disclaimer.html"><b>DISCLAIMER</b></a>
<br>
<a href="/soldiers-of-death">Soldiers Of Death (My Book)</a>
<br>
<a href="https://flattr.com/submit/auto?user_id=harsha_mudi&url=http%3A%2F%2Flexical.foobar.systems" target="_blank"><img src="//api.flattr.com/button/flattr-badge-large.png" alt="Flattr this" title="Flattr this" border="0"></a>
<br>
<br>
<a href="https://stackoverflow.com/users/1117082/mr-foobar"><img src="/images/so.png" width="33" height="33"/></a>
<a href="https://github.com/harsha-mudi"><img src="/images/gh.png" width="33" height="33"/></a>
<a href="https://www.npmjs.org/~harsha-mudi"><img src="https://www.npmjs.com/static/images/npm-logo.svg" width="55" height="33"/></a>
<a href="https://metacpan.org/author/MUCKER"><img src="/images/mp.jpg" width="33" height="33"/></a>
<a href="https://rubygems.org/profiles/mr-foobar"><img src="/images/ruby.png" width="33" height="33"/></a>
<a href="https://pay.reddit.com/user/rm-foobar"><img src="/images/r.jpg" width="33" height="33"/></a>
<a href="https://twitter.com/harsha_mudi"><img src="/images/tw.png" width="33" height="33"/></a>
<a href="https://soundcloud.com/mr-foobar"><img src="/images/sc.png" width="33" height="33"/></a>
<a href="https://vimeo.com/mrfoobar"><img src="/images/vm.png" width="33" height="33"/></a>
<a href="https://mrfoobar.bandcamp.com/"><img src="/images/bc.png" width="33" height="33"/></a>
</nav>




<h2>The Myth of Software Reuse</h2>
<div class="lineno"></div>

<article class="post">The Myth of Software Reuse gives you the following claims

- Easier to use
- Maintainable
- Cheap components / plugins / modules

I have a Gameboy ~~ 10 years.
A bike ~~ 7 years.
A watch ~~ 12 years.

Each of them has good cheaply available parts which can be used for

- Decoration
- Maintenance
- Upgrades

It is on the success of Engineering, Software Engineers make the
claims of reuse.

Sadly most claims remain more exaggerated than true.

For example, the Factory Pattern doesn't have the notion of pipelines
and yet it is supposed to help us somehow into making the "car" objects.

Can we be inspired by Engineering to do better ?

Cars
====

Engineering products typically have series and each series typically has generations.

For a car company, we can imagine a A series and a B series.

A1
A2
within A.

B1
B2
B3
B4
within B.

Firstly A and B can be so different, the only thing common between them is primitives
and designs ideas.

For Software this is,

- Primitives
- Data Structures
- Algorithms
- Patterns

For A and B, the manufacturing pipeline can be common.

- Build Process

Between A and B

- User Interfaces can be shared, upgraded and themed.

Within

A1
A2

Old components can be

* Reused
* Replaced
* Modified internally

- Module Set

Module Set
==========

The maximum reuse happen at Primitives, Data Structures ...
Important reuse goes into to Architectural/Design Patterns.

For flexible UI, create common and flexible Interfaces.

The most ignored is the "Module Set".
With the help of such a set we get easy Build Steps and Internal reuses.

<b>What is a Module ?</b>

A Module has
1. input
2. output
3. reconfigurability
4. connectivity

To create a Module Set is a Creative Process.

** It is a skill, not a framework **

The Set can be divided into two aspects.
Data Flow and Control Flow.

Data Flow is made up of Data Paths and Transformations.

Control Flow represents
1. Steps
2. Sequencing

Steps and Transformations are easy to Modularise.
Sequencing can be modularized with the help of decision trees.

Summary
=======

To reuse, just stick to off-the-shelf

* Primitives
* Patterns

Each should however be implementable by-hand, when absent as a library.
In fact the library should not be different from a hypothetical implementation by-hand.
Any fluff just muddles the pure Design Concepts.

Learn Module Decomposition.

A litmus test for a programmer understanding modularity
is whether he can implement a plugin system.</article>
<div style="height:22px; clear: both">
&nbsp;
</div>
<h2 class="blue"><a href="https://github.com/harsha-mudi/lexical-tasklists/issues"><b>issues</b></a></h2>
<h2>see also:</h2>
<div>

    
        <h4><a href="/tags/programming.html">programming</a></h4>
    

</div>

<div style="height:55px; clear: both">
&nbsp;
</div>
<div style="text-align: center">CC BY-NC 2014 foobar</div>
</body>
</html>
