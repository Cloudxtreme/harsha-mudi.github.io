<!DOCTYPE html>
<head>
<html>
<meta charset="utf-8">
<title> The Myth of Software Reuse </title>
<meta name="viewport" content="width=960,initial-scale=1">
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate"/>
<meta http-equiv="Pragma" content="no-cache"/>
<meta http-equiv="Expires" content="0"/>

  <script src="/vendor/jquery/dist/jquery.min.js"></script>
  <script src="/js/bundle.min.js"></script>
  <link rel="stylesheet" href="/css/styles.less.min.css">

</head>
<body>

<!--[if lt IE 8]>
<p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> to improve your experience.</p>
<![endif]-->


<nav>
<h1>Harsha <a href="http://www.foobar.systems"><img src="/images/floppy.png" width="33" height="33"/></a> Mr. Foo Bar (‸‶</h1>
<a href="/">Index</a>
<a href="/disclaimer.html"><b>DISCLAIMER</b></a>
<a href="https://flattr.com/submit/auto?user_id=harsha_mudi&url=http%3A%2F%2Flexical.foobar.systems" target="_blank"><img src="//api.flattr.com/button/flattr-badge-large.png" alt="Flattr this" title="Flattr this" border="0"></a>
<br>
<br>
<a href="https://stackoverflow.com/users/1117082/mr-foobar"><img src="/images/so.png" width="33" height="33"/></a>
<a href="https://github.com/harsha-mudi"><img src="/images/gh.png" width="33" height="33"/></a>
<a href="https://www.npmjs.org/~harsha-mudi"><img src="https://www.npmjs.org/static/img/npm.png" width="55" height="33"/></a>
<a href="https://metacpan.org/author/MUCKER"><img src="/images/mp.jpg" width="33" height="33"/></a>
<a href="https://rubygems.org/profiles/mr-foobar"><img src="/images/ruby.png" width="33" height="33"/></a>
<a href="https://pay.reddit.com/user/rm-foobar"><img src="/images/r.jpg" width="33" height="33"/></a>
<a href="https://twitter.com/harsha_mudi"><img src="/images/tw.png" width="33" height="33"/></a>
<a href="https://soundcloud.com/mr-foobar"><img src="/images/sc.png" width="33" height="33"/></a>
<a href="https://vimeo.com/mrfoobar"><img src="/images/vm.png" width="33" height="33"/></a>
<a href="https://mrfoobar.bandcamp.com/"><img src="/images/bc.png" width="33" height="33"/></a>
</nav>




<h2>The Myth of Software Reuse</h2>
<div class="lineno"></div>

<article class="post">The Myth of Software Reuse gives you the following claims

- Easier to use
- Maintainable
- Cheap components / plugins / modules
- Robust

I have a Gameboy ~~ 10 years.
A bike ~~ 7 years.
A watch ~~ 12 years.

Each of them has good cheaply available components which can be used for

- Decoration
- Maintainance
- Upgrades

It is on the success of Engineering, Software Engineers make the
claims of reuse.

Sadly most claims remain more exaggerated than true.

For example, the Factory Pattern doesn't have the notion of pipelines
and yet it is supposed to help us somehow into making the car objects.

Can we be inspired by Engineering to do better ?

Cars
====

Engineering products typically have series and each series typically has generations.

For a car company, we can imagine a A series and a B series.

A1
A2
within A.

B1
B2
B3
B4
within B.

Firstly A and B can be so different, the only thing common between them is primitives
and designs ideas.

For Software this is,

- Primitives
- Data Structures
- Algorithms
- Architectural Patterns
- Design Patterns

For A and B, the manufacturing pipeline can be common.

- Build Process

Between A and B

- User Interfaces can be shared, upgraded and themed.

Within

A1
A2

Old components can be

* Reused
* Replaced
* Modified internally

- Hierarchy of Modules

Summary
=======

The maximum reuse happen at Primitives, Data Structures ...
Important reuse goes into to Architectural/Design Patterns.

The most important is the "Hierarchy of Modules".
With the help of such a hierarchy we get easy Build Steps and Internal reuses.

How can we have a Modules ?

* Functions + Namespaces
* OOP + Messaging
* REST APIs
* DLLs
* Actors
* Active Objects
* Flow Components

To decompose into a Hierarchy is a Creative Process.
It is not meant to be guided by the notion of reuse but by that of Efficiency.

** It is a skill, not a framework **

The key is, a Module should have well-behaved Input / Output / Communication channels.

To reuse, just stick to off-the-shelf

* Primitives
* Patterns
* Module Abstractions

and learn Functional Decomposition.

Each can however be implemented by-hand, when absent as a library.
Infact the library should not be different from a hypothetical implementation by-hand.

Most frameworks/langs aren't that explicit, however.
They promise you silver and give you stacktraces.</article>
<div style="height:22px; clear: both">
&nbsp;
</div>
<h2 class="blue"><a href="https://github.com/harsha-mudi/lexical-tasklists/issues"><b>issues</b></a></h2>
<h2>see also:</h2>
<div>

    
        <h4><a href="/tags/philosophy.html">philosophy</a><br></h4>
    

    
        <h4><a href="/tags/programming.html">programming</a></h4>
    

</div>

<div style="height:55px; clear: both">
&nbsp;
</div>
<div style="text-align: center">CC BY-NC 2014 Harsha</div>
</body>
</html>
